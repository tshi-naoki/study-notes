# 面向对象与面向过程

## 什么是面向过程

把问题分解成一个一个步骤，每个步骤用函数实现，一次调用即可

就是说，在进行面向过程的编程过程中，不需要考虑这么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行

最典型的用法就是实现一个简单的算法，比如实现冒泡模式

比较底层的算法都是面向过程的，根据最基本的思考过程把逻辑写出来

## 什么是面向对象

将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之前的调用，组合解决问题

就是说，在进行面向对象进行编程的过程中，要把属性、行为等封装成一个对象，然后基于对象以及对象的能力进行业务逻辑的实现

比如：想要造一辆车，上来要先把车的属性定义出来，然后抽象成一个Car类

## 举例说明区别

同样一个象棋设计

面向对象：创建黑白双方的对象负责演算，棋盘的对象负责画布，规则的对象负责判断，例子可以看出，面向对象更重视不重复造轮子，即创建一次，重复使用

面向过程：开始-黑走-棋盘-判断-白走-判断-循环，只需要关注每一步怎么实现即可

## 优劣势对比

面向对象：占用资源相对高，速度相对慢

面向过程：占用资源相对低，速度相对快

## 总结

其实我觉得刚开始思考的过程都是面向过程，然后面向对象在面向过程思考的过程之后思考明白之后，知道了要把什么抽象成一个对象，让这个对象实现什么功能，之后把不同的对象组合起来，达到我们要实现的功能

# 面向对象的三大特征

## 封装

就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的信息隐藏，封装是面向对象的特征之一，是对象和类概念的主要特性

简单的说一个类就是一个封装了数据以及操作这些数据的代码逻辑实体，在一个对象内部，某些代码或者某些数据可以私有，不能被外界访问，通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用对象的私有部分

## 继承

继承是指一种能力，它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展，通过继承创建的新类称为子类或者派生类

被继承的类称为基类、父类或者超类

继承的过程就是从一般到特殊的过程，要实现继承，可以通过继承和组合的方式来实现

继承的概念的实现方式有二类：

- 实现继承：实现继承是指直接使用基类的属性和方法而无需额外的编码能力
- 接口继承：仅使用属性和方法的名称，但是子类必须提供实现的能力

## 多态

多态就是一个类在实例的相同方法在不同情形下有不同的表现形式

多态机制使具有不同内部结构的对象可以共享相同的外部接口

虽然针对不同对象的具体操作不同，但是通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用

最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。

## 总结

封装、继承、多态

# 面向对象的五大基本准则

## 单一职责

一个类最好就是只做一件事，只有一个引起它的变化

单一职责可以看作高内聚、低耦合在面向对象原则上的引申

## 开放封闭

软件实体应该是可扩展的而不可修改的

**对扩展开放对修改封闭**

对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况

对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改

**实现的方式就是**：面向抽象编程，而不是对具体编程，因为抽象相对稳定，让类依赖于固定的抽象，所以修改就是封闭的

而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的

## 里氏替换

子类必须能够替换基类，在系统运行时环境下载能够识别子类

**实现方式是面向接口编程**：将公共部分抽象成接口或者抽象类

## 依赖倒置

其核心思想就是依赖于抽象，从原本的依赖于某个实现了具体事务的类改变为依赖于这个类的抽象

在依赖之间定义一个抽象的接口使得搞成模块调用接口

## 接口隔离

使用多个小的接口，而不是使用一个大的总接口，将接口中的多个声明方法中关联的拆分成多个小的接口，让实现去实现多个接口

具体而言就是接口应该是内聚的，避免胖接口

## 总结

其实也有说面向对象是有七大原则，除了上面的五个，还有：迪米特法则、合成/聚合原则

### 迪米特法则

又叫最少知道原则

一个对象应该对其他对象保持最少的了解。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。

如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。

**也就是只与直接朋友通信，实在是需要与不是直接朋友通信，可以通过中介进行交互，这样如果其中某一方发生了变化，可以在中介中处理这个差异**


出现的问题：由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。故过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。

### 合成/聚合原则

也叫做合成复用原则，及尽量使用合成/聚合，尽量不要使用类继承。

也是就尽量使用组合代替继承，比如在has-a关系中，就应该使用组合，身体拥有头部。

为什么要尽量使用合成/聚合而不使用类继承？

1. 对象的继承关系在编译时就定义好了，所以无法在运行时改变从父类继承的子类的实现

2. 子类的实现和它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化

3. 当你复用子类的时候，如果继承下来的实现不适合解决新的问题，则父类必须重写或者被其它更适合的类所替换，这种依赖关系限制了灵活性，并最终限制了复用性。
